Maybe Hash Table!!
DEAFULT_KEY: 0
Running modulo vs bit-shift benchmark with 100000000 iterations...
Comparing three methods:
  1. Non-prime modulo:     i % ((1 << 32) - 6)
  2. Power of two bitmask: i & ((1 << 32) - 1)
  3. Mersenne prime shift: hash_bin_index(i, 32)

Benchmarking non-prime modulo...
Benchmarking power of two bitmask...
Benchmarking Mersenne prime bit-shift (hash_bin_index)...

╔════════════════════════════════════════════════════════════════╗
║              MODULO vs BIT-SHIFT BENCHMARK RESULTS             ║
╚════════════════════════════════════════════════════════════════╝

=== Method Comparison ===
  Non-prime modulo ((1 << 32) - 6):     54.130 ms
  Power of two bitmask ((1 << 32) - 1): 10.303 ms
  Mersenne prime bitshift:              22.773 ms

=== Performance Analysis ===
  Fastest method: Power of two bitmask (10.303 ms)

  Relative performance:
    Non-prime modulo:        5.25x slower than fastest
    Power of two bitmask:    1.00x slower than fastest
    Mersenne prime bitshift: 2.21x slower than fastest

=== SUMMARY ===
Power of 2 bitmask:
  - Uses: i & (2^n - 1) instead of i % 2^n
  - Simple AND operation, very fast

Mersenne prime bitshift:
  - Uses: hash_bin_index for i % (2^n - 1)
  - Formula: y = (x >> n) + (x & (2^n - 1)); return (y > 2^n - 1) ? y - (2^n - 1) : y
  - More complex but avoids expensive modulo

Non-prime modulo:
  - Uses: standard % operator
  - No bit-shift optimization available
