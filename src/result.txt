Maybe Hash Table!!
DEAFULT_KEY: 0
Running modulo vs bit-shift benchmark with 100000000 iterations...
Comparing four methods:
  1. Non-prime modulo:     i % ((1 << 32) - 6)
  2. Power of two bitmask: i & ((1 << 32) - 1)
  3. Mersenne prime shift: hash_bin_index(i, 32)
  4. Mersenne prime modulo: i % ((1 << 32) - 1)

Benchmarking non-prime modulo...
Benchmarking power of two bitmask...
Benchmarking Mersenne prime bit-shift (hash_bin_index)...
Benchmarking Mersenne prime modulo...

╔════════════════════════════════════════════════════════════════╗
║              MODULO vs BIT-SHIFT BENCHMARK RESULTS             ║
╚════════════════════════════════════════════════════════════════╝

=== Method Comparison ===
  Non-prime modulo ((1 << 32) - 6):     48.130 ms
  Power of two bitmask ((1 << 32) - 1): 9.966 ms
  Mersenne prime bitshift:              22.333 ms
  Mersenne prime modulo:                37.890 ms

=== Performance Analysis ===
  Fastest method: Power of two bitmask (9.966 ms)

  Relative performance:
    Non-prime modulo:        4.83x slower than fastest
    Power of two bitmask:    1.00x slower than fastest
    Mersenne prime bitshift: 2.24x slower than fastest
    Mersenne prime modulo:   3.80x slower than fastest

=== SUMMARY ===
Power of 2 bitmask:
  - Uses: i & (2^n - 1) instead of i % 2^n
  - Simple AND operation, very fast

Mersenne prime bitshift:
  - Uses: hash_bin_index for i % (2^n - 1)
  - Formula: y = (x >> n) + (x & (2^n - 1)); return (y > 2^n - 1) ? y - (2^n - 1) : y
  - More complex but avoids expensive modulo

Mersenne prime modulo:
  - Uses: i % (2^n - 1)
  - Standard modulo with Mersenne prime

Non-prime modulo:
  - Uses: standard % operator
  - No bit-shift optimization available
