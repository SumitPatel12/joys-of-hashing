## Random Stuff
- You'd need to identify if a bin/slot is in use or not. For that you can:
  - Either have a bit in the bins that indicates whether that bin is initialized or not. This however has big scope for space unerutilization since we can't have just one bit, so it'd either be 1 byte or more depending on the alignment setting of the machine you're using likely 32-bits or 64-bits out of which just 1 bit is useful, remainig 31 or 63 are just overhead.
  - OR, you can assign a value (from the possible values for the key) as a default value. That value will indicate that the bin is uninitialized. This has better space unerutilization, but you're letting go of one key from the range, so you'll have to make sure that the key you choose would never be generated by the end user. If they ever generate that default value, it'll never be represented correctly in the hash table.

## Mapping from Keys to Indice Bins
Well the most rudimentary way to map N to m would be to use a modulo operator:
```c
static inline unsigned int
hash_bin_index(struct hash_table* table, unsigned int key) {
    // Modulos are costly so, you'd either take a power of 2 or a Mersenne prime to reduce these to bitwise and add/subtract opeartors for better performance.
    return key % table->size;
}
```

While this would look like a good method it's not a good one, because it's really easy to carft an input that would lead to a very skewed distribution. Think you end up getting numbers that leave a reaminder of say R for 50% of the keys. Now your modulo function maps 50% of the keys to the same bin which is not what we want. There are dedicated hash functions for things like these, and which is a best fit for your use-case is something that you'll have to research and decide upon.

That aside, you'll generally want the size of the hash_table to be a perfect power of 2. It helps with alignment and some pointer arethmetic can be optimized to simple bit manipulation operations. Also, most of the time **hash keys come in computer words** which themselves are a power of 2, this leads to the table size being a perfect divisor of the key space leading to better distribution of sorts.

### Prime numbers and Indexing
Often times, the keys we need to store have some periodic property to them, like pointers, would grow in a fixed factor depending on what the pointer points to. For `int` it'd be 4, 8, 12, etc. Now, if m is also a power of 2 say 16, then you'll end up using only a couple of the bins of the available 16:
- 0  mod 16 -> 0
- 4  mod 16 -> 4
- 8  mod 16 -> 8
- 12 mod 16 -> 12
- After 16 it'll just repeat
In essence you end up using only 4 of the 16 availalbe bins leading to really bad performance on your otherwise well designed hash_table.

What you can do to mitigate that is use a prime number, a periodic repetition on a prime number other than 2 is a rare occurrence and dividing by a prime will help normalize the distribution.
For the code, you can select the smallest prime bigger than the table size, modulo our key by that prime then modulo by the table size. If the table size is a power of 2, say 2<sup>k</sup>. Then getting the remainder is the same as **masking out the lower k bits of the key.**

```c
static inline unsigned int
hash_bin_index(struct hash_table* table, unsigned int key) {
     unsigned int mask = table->size - 1;
     unsigned int prime = next_prime();
     reutrn (key % prime) & mask;
}
```
And, while this optimization is good, if your hash function takes ages to compute this will of little help.

You can also go the route of taking the table size (m) as prime, you can go with [Mersenne primes](https://mathworld.wolfram.com/MersennePrime.html). They are of the form 2<sup>p</sup> - 1. One such is for p = 61, which can likely be a good fit for 32 bit words.

Now get ready for some math. :evil_laugh: x 3. (I like poor jokes bite me).

- x will be a 32 bit word.
- Let *p = 2<sup>s</sup> - 1, and x < p.*
- Transform x to a form of: **a2<sup>s</sup> + b**, b < 2<sup>s</sup>. So, we get x mod p = b.
  - Essentially **b would be the last s bits of x**, and **a would be the reamining bits after removing last s bits.**
- Which leads us to **x mod p = a + b**, since we're adding stuff, it might be that we overflow, i.e. a + b > p, but since both a and b are less than or equal to p, we've got a + b <= 2p.
  - So, if a + b < p, then our answer is p.
  - Otherwise, answer is (a + b) - p.

```c
// s can only be so big if we want to store it :shrug:
uint64_t mod_mersenne(uint64_t x, uint8_t s) {
    uint64_t p = (uint64_t)(1 << s) - 1;
    uint64_t y = (x >> s) + (x & p);
    return (y > p) ? y - p : y;
}
```

## Collission Math!!
I was too lazy to type it after I did it on the board once :shrug:
The formula for at least one collission given n keys hashing to m bins, and n <= m is:
![Formula](../assets/Probability_Formula.png)

Proof:
![Proof](../assets/Probability_Proof.png)
